---
category: '编程'
tags: ['js','编程知识','数组']
cover: 'javascript'

---


###### 25060801
 
<br/>
 
## 1. 简单需求

### 1.1 将数组倒序排列

- 利用 `reverse()` ,会改变原数组

```js
const arr = [1, 2, 3, 4, 5];
arr.reverse();
console.log(arr); // 输出: [5, 4, 3, 2, 1]
```

## 1.2 提取数组每一项的属性值，形成新数组

```js
const originalArray = [
  { id: 1, name: 'Alice', age: 25 },
  { id: 2, name: 'Bob', age: 30 },
  { id: 3, name: 'Charlie', age: 28 }
];

// 提取所有 name 属性值
const names = originalArray.map(item => item.name);
console.log(names); // 输出: ['Alice', 'Bob', 'Charlie']

// 提取所有 age 属性值
const ages = originalArray.map(item => item.age);
console.log(ages); // 输出: [25, 30, 28]
```

### 1.3 数组去重

```js
const arr = [1, 2, 2, 3, 'a', 'a'];
const unique = [...new Set(arr)];
// 结果: [1, 2, 3, 'a']
```

## 2. 多维数组

### 2.1 将多维数组转为一维数组



```js 
const reArrange = (data, list=[]) => {
    data.forEach((item) => {
        if (item.children && item.children.length > 0) {
            reArrange(item.children, list);
        } else {
            list.push(item);
        }
    });
    return list;
};
```



```js 
// 重组数据函数
const reArrange = (data, list=[]) => { // 设置list的起始值，因为内部会再次调用函数，必须存在list变量
    // 利用 forEach 遍历数据
    data.forEach((item) => {
        // 当数据中存在子代时，会再次执行，遍历子代数据，直到找到末端数据
        if (item.children && item.children.length > 0) {
            reArrange(item.children, list);
        // 没有子代，直接生成新的数组内容
        } else {
            list.push(item);
        }
    });
    return list;
}
```



###  2.2 JS如何对深层嵌套的数组进行增删改查



```js
const data = [
    {
        name: "111",
        id: 1,
        child: [
            {
                name: "222",
                id: 2,
                child: [],
            },
            {
                name: "333",
                id: 3,
                child: [
                    {
                        name: "444",
                        id: 4,
                        child: [],
                    },
                    {
                        name: "555",
                        id: 5,
                        child: [],
                    },
                ],
            },
        ],
    },
    {
        name: "666",
        id: 6,
        child: []
    },
    {
        name: "777",
        id: 7,
    }
];

//1， 扁平结构 数据接口 key值可以 遍历
var arr = []

function fixData (data, status, parent, level=0) {
    //console.log("data: ", data);
    data.length>0&&data.map((item) => {
        var obj = { ...item };
        if (status == 1) {
            obj.parentId = parent.id;
            console.log("itemm: ", obj);
        }

        if ((item.child && item.child == 0) || !item.child) {
            arr.push(obj);
        } else {
            obj.child = [];
            obj.isParent = true;
            obj.level = level+1;
            arr.push(obj);
            fixData(item.child, 1, item, obj.level);
            console.log(item,'item');
            
        }
    });

}
fixData(data)

console.log('arr: ', arr);

//2， 更新数据
var forObj = {}
arr.map(v => {
    forObj[v.id]=v
})
console.log("forObj: ", forObj);
console.log("forObj_findKey: ", forObj["1"]);

// 3，还原数据

async function originData(forObj){
    var arr = []
    Object.keys(forObj).forEach((key)=>{
        console.log(key, forObj[key]);
        arr.push(forObj[key]);
    })
    console.log("arr: ", arr);

    var originObj = {}
    var originArr = []
    var originChildArr = []
    await arr.map(item => {
        if (item.isParent || !item.parentId) {
            originArr.push(item);
        } else {
            originChildArr.push(item);
        }
    })

    console.log(originArr)
    console.log(originChildArr)

    await originChildArr.map(item => {
        originArr.map(v => {
            if(item.parentId == v.id){
                v.child.push(item)
            }
        })
    })
    
    console.log(originArr);

    var eleOriginArr = [...originArr];
    await eleOriginArr.map((v,index)=> {
        v.index = index
        originObj[v.id] = v;
    })
    console.log("originObj: ", originObj);
    await originArr.map((item,i) => {
        var targetObj = originObj[item.id+""]
        if(targetObj.parentId){
            var objj = originObj[targetObj.parentId + ""];
            if (objj) {
                originArr.splice(i, 1);
                objj.child.push(targetObj);
            }
        }

    })
    console.log("originArr: ", originArr);



    //await originArr.map((item,i) => {
    //     eleOriginArr.map((v)=> {
    //        if(item.id==v.id)return

    //        if (item.parentId == v.id) {
    //            v.child.push(item);
    //            console.log("iiii: ", i)
    //            eleOriginArr.splice(i,1)
    //        }

    //    })
    //});

    console.log("eleOriginArr: ", eleOriginArr);
    
}
originData(forObj);
```


## 遍历数组增加属性

```js

// 生成符合 element 规范的属性 
const sites = ref([])

const resetData = (momo = []) => {
    let arr = []
    for (let i = 0; i < momo.length; i++) {
        let obj = {}
        obj = momo[i]
        obj.value = momo[i].title
        obj.label = momo[i].title
        arr.push(obj)
        obj.children = resetData(momo[i].items)


    }
    return arr
}
sites.value = resetData(sites_data)

```